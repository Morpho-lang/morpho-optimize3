// Simple loop minimization problem solved with SQP

import meshtools 
import optimize3
import plot 

var m = LineMesh(fn (t) [1.2*cos(t),sin(t)], -Pi...Pi:Pi/20, closed=true)

var problem = OptimizationProblem(m)

var ll = Length() 
problem.addenergy(ll)

var la = AreaEnclosed() 
problem.addconstraint(la)

var adapt = MeshAdapter(problem, m)

var _OptUnConsErr = Error("OpUncons", "Problem appears to be unconstrained.")
var _OptLnSrchDrn = Error("OptLnSrchDrn", "Linesearch encountered an upward direction.")

class XLineSearchController is LineSearchController {
  setexpecteddescent(df) {
    self.df = df
    if (self.df>0) self.warning(_OptLnSrchDrn)
  }

  expecteddescent() { // Predict expected descent
    return self.df
  }
}

class L1PenaltyAdapter is DelegateAdapter {
  init(adapter, penalty=1) {
    self.adapter = adapter
    self.penalty = penalty
  }

  constraintvector() {
    var v = self.adapter.constraintvalue()
    return Matrix(v)
  }

  value() { //  f + lambda_i c_i
    var f = self.adapter.value() 
    var c = self.constraintvector()

    return f + self.penalty*c.norm(1)
  }

  directionalderivative(d) {
    var df = self.adapter.gradient() 
    var c = self.constraintvector()

    return df.inner(d) - self.penalty*c.norm(1)
  }
}

class LagrangeMultiplierAdapter is OptimizationAdapter {
  init(adapter) {
    self.adapter = adapter
    self.nconstraints = self.constraintvector().count() 
    self.lambda = Matrix(self.nconstraints)
  }

  set(x) { // Get parameters, stripping off lagrange multipliers
    var n = x.count()
    var nvars = n - self.nconstraints
    self.adapter.set(x[0...nvars,0])
    self.lambda = x[nvars...n,0] // Store lagrange multipliers on this adapter
  }

  get() { // Get parameters, joining real parameters with lagrange multipliers
    var x = self.adapter.get()
    return Matrix([[x], [self.lambda]]) 
  }

  lagrangemultipliers() {
    return self.lambda 
  }

  _checkineq(c) {
    var nc = self.adapter.countconstraints()
    for (k in nc[0]...nc[0]+nc[1]) {
      if (c[k]>0) c[k]=0
    }
  }

  constraintvector() {
    var v = self.adapter.constraintvalue()

    if (v) {
      v = Matrix(v)
      self._checkineq(v)
    } else _OptUnConsErr.warning() 

    return v 
  }

  value() { // Lagrangian = f + lambda_i c_i
    var f = self.adapter.value() 
    var c = self.constraintvector()

    return f + self.lambda.inner(c)  
  }

  vargradient() { // Gradient of lagrangian wrt original degrees of freedom
    var grad = self.adapter.gradient()
    var cgrad = self.adapter.constraintgradient()
    for (cg,k in cgrad) grad += self.lambda[k]*cg

    return grad 
  }

  gradient() { // Gradient of Lagrangian is [ df + lambda_i dc_i , c_i] 
    var c = self.constraintvector()

    return Matrix([[self.vargradient()],[c]]) 
  } 

  hessian() { // Hessian of Lagrangian is the kkt matrix 
    var h = self.adapter.hessian()    

    var chess = self.adapter.constrainthessian() 
    for (ch,k in chess) h += self.lambda[k]*ch

    var cg = self.adapter.constraintgradient()
    var C = Matrix([cg])

    return Matrix([[h, C],[C.transpose(), 0]])
  }
}

class XLBFGSController is InvBFGSController {
  init(adapter, quiet=false, verbosity=nil, maxhistorylength=10) {
    super.init(adapter, quiet=quiet, verbosity=verbosity)
    self.maxhistorylength = maxhistorylength
  }

  _popfirst(lst) { // Pops the first element of a list
    var a = lst.roll(-1)
    a.pop() 
    return a 
  }

  _hmul(p) { // Compute the action of our approximation to the inv H on a vector or matrix 
    var q = p

    var n = self._storage.count() 
    if (n==0) return q
    
    var alpha[n]

    // Project off all components of p that lie in the history directions
    for (k in n-1..0:-1) { // Start with most recent
      var z = self._storage[k]
      var sk = z[0], yk = z[1], rho = 1/z[2]

      alpha[k] = rho * sk.transpose()*q //sk.inner(q)
      q-=yk*alpha[k]
    } 

    var zl = self._storage[-1] // Last 
    var r = (zl[2]/zl[3])*q // (sk.yk)/(yk.yk)

    for (z, k in self._storage) { // Work forwards
      var sk = z[0], yk = z[1], rho = 1/z[2]

      var beta = rho * yk.transpose()*r// rho*yk.inner(r)
      r+=sk*(alpha[k]-beta)
    }

    return r 
  }

  start() {
    self._storage = []
  }

  direction() {
    return -self._hmul(self.gradient())
  }

  update(sk, yk) {
    self._storage.append((sk, yk, sk.inner(yk), yk.inner(yk)))

    if (self._storage.count()>self.maxhistorylength) self._storage = self._popfirst(self._storage)
  }

  next() { // Update our estimate of the inverse Hessian
    var sk = self.get() - self._ox
    var yk = self.gradient() - self._ogradient

    self.update(sk, yk) 
  }
}

class SQPController is OptimizationController {
  gradient() {
    return self.ladapter.gradient()
  }

  kkt() {
    return self.ladapter.hessian() 
  }

  start() {
    self.ladapter = LagrangeMultiplierAdapter(self.adapter)

    self.lbfgs = XLBFGSController(self.adapter)
    self.lbfgs.start() 
  }

  begin() {
    self._ox = self.get() 
    self._ogradient = self.ladapter.vargradient() 
  }

  Xsolve() {
    var rhs = self.gradient() 
    var kkt = self.kkt() 
    var d = -rhs/kkt
  }

  solve() {
    var g = self.ladapter.vargradient() 
    var c = self.ladapter.constraintvector()
    var cg = self.adapter.constraintgradient()
    var C = Matrix([cg])
    var Ct = C.transpose()

    var HC = self.lbfgs._hmul(C)
    var Hg = self.lbfgs._hmul(g)

    var S = -Ct*HC
    var Sinvc = c/S
    var SinvCt = Ct/S

    return -Matrix([ [Hg + HC*SinvCt*Hg - HC*Sinvc],
                     [- SinvCt*Hg + Sinvc] ])
  }

  linesearch(dirn) {
    var x0 = self.adapter.get()

    var padapt = L1PenaltyAdapter(self.adapter, penalty=10)

    var ndof = self.adapter.get().count() 
    var xdirn = dirn[0...ndof]

    var ls = XLineSearchController(padapt)
    ls.setdirection(xdirn)
    var df = padapt.directionalderivative(xdirn)
    ls.setexpecteddescent(df)
    ls.step()

    self.adapter.set(x0)

    return ls.stepsize
  }

  step() {
    var x0 = self.ladapter.get()

    var d = self.solve() 
    var alpha = self.linesearch(d)

    self.ladapter.set(x0 + alpha*d)
    self.stepsize = alpha 
  }

  reportstepsize() { return "stepsize=${self.stepsize}" }

  next() {
    var sk = self.get() - self._ox
    var yk = self.ladapter.vargradient() - self._ogradient
    
    self.lbfgs.update(sk, yk)
  }
}

var control = SQPController(adapt)
control.optimize(100)

Show(plotmesh(m))

print "Length=${Length().total(m)} Area = ${AreaEnclosed().total(m)}"

print control.adapter.constraintvalue()
