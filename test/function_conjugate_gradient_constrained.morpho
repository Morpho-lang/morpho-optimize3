// Test the FunctionAdapter on a simple quadratic with a linear constraint

import optimizationadapter
import optimizationcontroller

fn func(x, y, z) {
    return (x-0.5)^2 + 0.5*(y-1)^2 + 2*(z-2)^2
}

fn g(x, y, z) {
    return x + y - 1
}

var _MaxIterCons = Error("MaxIterCons", "Too many steps in constraint satisfaction.")

class ProjectedConjugateGradientController is ConjugateGradientController {
  init(adapter, quiet=false, stepsize=0.1) { 
    super.init(adapter, quiet=quiet, stepsize=stepsize)
    self.maxconstraintsteps = 100
  }

  searchdirection() {
    super.searchdirection()

    var cgrad = self.adapter.constraintgradient()

    for (g in cgrad) {
      var dg = self._direction.inner(g)
      var gg = g.inner(g)

      self._direction -= (dg/gg)*g 
    }
  }

  reproject() {
    var x = self.adapter.get()

    var dv = Matrix(1)

    for (_ in 1..self.maxconstraintsteps) {
      dv = Matrix(self.adapter.constraintvalue())
      if (dv.norm()<self.ctol) return 

      var cgrad = self.adapter.constraintgradient()
      var n = cgrad.count()

      var M = Matrix(n,n)
      for (i in 0...n) for (j in i...n) M[i,j]=cgrad[i].inner(cgrad[j])

      var scale=dv/M

      for (i in 0...n) x -= scale[i]*cgrad[i]
      
      self.adapter.set(x)
    }

    _MaxIterCons.warning("Maximum number of constraint steps exceeded without achieving the constraint tolerance of ${self.ctol} (residual is ${dv.norm()}). Try setting 'maxconstraintsteps' to more than ${self.maxconstraintsteps}, or increase constraint tolerance.")
  }
  
}

var start = Matrix([0.5,0.5,0])

var adapt = FunctionAdapter(func, start=start, constraints = [g])

var control = ProjectedConjugateGradientController(adapt)

control.optimize(100)

print "Solution:"
print adapt.get()