// Test LBFGS on a poorly scaled quadratic

import optimize3

fn f(x, y, z, u) {
  return (x-0.5)^2 + 0.5*(y-1)^2 + 2*(z-2)^2 + u^2
}

fn g(x, y, z, u) {
  return x + y - 1
}

fn h(x, y, z, u) {
  return z + u - 1
}

var start = Matrix([0,0,0,0])

var adapt = FunctionAdapter(f, start=start, constraints = [g])

class ConstrainedLBFGSController is LBFGSController {
  start() {
    super.start()

    self._lambda = Matrix(self.adapter.countconstraints())
  }

  _hmul(p) { // Compute the action of our approximation to the inv H on a vector 
    var q = p

    var n = self._storage.count() 
    if (n==0) return q
    
    var alpha[n]

    // Project off all components of p that lie in the history directions
    for (k in n-1..0:-1) { // Start with most recent
      var z = self._storage[k]
      var sk = z[0], yk = z[1], rho = 1/z[2]
      alpha[k] = rho*sk.inner(q)
      q-=alpha[k]*yk
    } 

    var zl = self._storage[-1] // Last 
    var r = (zl[2]/zl[3])*q // (sk.yk)/(yk.yk)

    for (z, k in self._storage) { // Work forwards
      var sk = z[0], yk = z[1], rho = 1/z[2]
      var beta = rho*yk.inner(r)
      r+=sk*(alpha[k]-beta)
    }

    return r 
  }

  searchdirection() {
    super.gradient()

    var cg = self.adapter.constraintgradient() 
    var a = Matrix([cg])

    var hinva = self._hmul(a)
    var aT = a.transpose()
    var S = - aT*hinva // Schur complement

    // Evaluate rhs of the Newton problem
    var g = -self._gradient
    var c = -self.adapter.constraintvalue() 

    // Evaluate the action of Inv(A) on the rhs of Newton
    var hinvg = self._hmul(g)
    var sainvg = aT*hinvg/S 
    var sinvc = c/S 

    self._direction = hinvg + hinva * (sainvg - sinvc)
    //self._dlambda = -sainvg + sinvc 
  }
}

var control = ConstrainedLBFGSController(adapt)

control.optimize(50)

print "Solution:"
print adapt.get()
