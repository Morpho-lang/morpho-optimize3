// Create a PenaltyAdapter 

import optimize3

class PenaltyAdapter is OptimizationAdapter {
  init(adapter, lambda=1) { 
    self.adapter = adapter
    self.lambda = lambda 
  }

  setpenalty(lambda) { self.lambda = lambda }
  penalty() { return self.lambda }

  set(x) { self.adapter.set(x) }
  get() { return self.adapter.get() }

  value() { // L = f + lambda*g^2
    var g = Matrix(self.adapter.constraintvalue())

    return self.adapter.value() + 
           self.lambda*g.inner(g)
  }

  gradient() { // grad L = grad f + 2*lambda*g*grad g
    var grad = self.adapter.gradient() 
    var g = self.adapter.constraintvalue()   
    var dg = self.adapter.constraintgradient()   

    for (dgk, k in dg) grad += 2*self.lambda*g[k]*dgk

    return grad
  }
}

fn func(x, y, z) {
    return (x-0.5)^2 + 0.5*(y-1)^2 + 2*(z-2)^2
}

fn g(x, y, z) {
    return x + y - 1
}

var start = Matrix([0,0,0])

var adapt = FunctionAdapter(func, start=start, constraints = [g])
var padapt = PenaltyAdapter(adapt)

for (i in 1..10) {
  padapt.setpenalty(10*padapt.penalty())

  var control = ConjugateGradientController(padapt)
  control.optimize(100)
}

print "Penalty ${padapt.penalty()}"

print "Solution:"
print padapt.get()
