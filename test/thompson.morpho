// Thompson problem demonstrating local equality constraints

import meshtools 
import optimize3
import functionals
import plot 

var Np = 12 // Number of particles

var build = MeshBuilder()
for (i in 1..Np) {
  var x = Matrix([2*random()-1, 2*random()-1, 2*random()-1])
  x/=x.norm() // Project onto unit sphere
  build.addvertex(x)
}
var mesh = build.build() // Tell the MeshBuilder to build the mesh

// Specify the problem
var problem = OptimizationProblem(mesh)

var lv = PairwisePotential(fn (r) 1/r, fn (r) -1/r^2)
problem.addenergy(lv)

var lsph = ScalarPotential(fn (x,y,z) x^2+y^2+z^2-1)
problem.addlocalconstraint(lsph)

fn localcons(mesh, func) {
    var grad = func.gradient(mesh)
    var dim = grad.dimensions()
    var ndof = dim[0], ncol = dim[1]

    var s = Sparse(ndof*ncol,ncol)

    for (i in 0...ncol) {
        for (x, j in grad.column(i)) s[i*ndof+j,i]=x
    }

    return s 
}

print localcons(mesh, lsph)

/*var g = Graphics()
for (i in 0...mesh.count()) {
  g.display(Sphere(mesh.vertexposition(i),1/sqrt(Np)))
}
Show(g) 
*/