// Suite of test functions
// See: https://en.wikipedia.org/wiki/Test_functions_for_optimization

import meshtools 
import optimize3

fn sphere(...x) {
  var sum = 0
  for (u in x) sum+=(u-1)^2
  return sum 
}

fn rosenbrock(...x) { // Sharp curved valley around minimum
  var n = x.count() 
  var sum = 0 
  for (var i=0; i<n-1; i+=1) {
      sum+=100*(x[i+1] - x[i]^2)^2 + (1-x[i])^2
  }
  return sum 
}

fn beale(x, y) { 
  return (1.5 - x + x*y)^2 + (2.25 - x + x*y*y)^2 + (2.625 - x + x*y^3)^2
}

fn booth(x, y) { // Asymmetric quadratic
  return (x + 2*y - 7)^2 + (2*x + y - 5)^2
}

fn bukin(x, y) { // Long, narrow valley 
  return 100*sqrt(abs(y-0.01*x^2)) + 0.01*abs(x+10)
}

fn easom(x, y) { // transcendental functions
  return -cos(x)*cos(y)*exp(-((x-Pi)^2 + (y-Pi)^2))
}

// Test functions: 
//              label            fn            n    fmin,   soln
var tests = [ [ "Sphere(2)",     sphere,       2,   0,      [1,   1] ],
              [ "Rosenbrock(2)", rosenbrock,   2,   0,      [1,   1] ],
              [ "Beale",         beale,        2,   0,      [3, 0.5] ],
              [ "Booth",         booth,        2,   0,      [1,   3] ]
              //[ "Bukin",         bukin,        2,   0,      [-10, 1] ]
              //[ "Easom",         easom,        2,   -1,     [Pi, Pi] ]
            ]


var adapt = FunctionAdapter(beale, start=Matrix(2))

var control = NewtonController(adapt, linesearch=LineSearchController)

control.optimize(400)
