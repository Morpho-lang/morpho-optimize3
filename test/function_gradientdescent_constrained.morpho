// Test the FunctionAdapter on a simple quadratic 

import optimizationadapter
import optimizationcontroller

fn func(x, y) {
    return (x-0.5)^2 + (y-1)^2
}

fn g(x, y) {
    return x + y - 1
}

var _MaxIterCons = Error("MaxIterCons", "Too many steps in constraint satisfaction.")

class ProjectedGradientDescentController is GradientDescentController {
  init(adapter, quiet=false, stepsize=0.1) { 
    super.init(adapter, quiet=quiet, stepsize=stepsize)
    self.etol = 1e-8
    self.ctol = 1e-10
    self.maxconstraintsteps = 100
    self._valuehistory=[]
  }

  value() {
    super.value() 
    self._valuehistory.append(self._value)
  }

  searchdirection() {
    super.searchdirection()

    var cgrad = self.adapter.constraintgradient()

    for (g in cgrad) {
      var dg = self._direction.inner(g)
      var gg = g.inner(g)

      self._direction -= (gg/dg)*g 
    }
  }

  reproject() {
    var x = self.adapter.get()

    var dv = Matrix(1)

    for (_ in 1..self.maxconstraintsteps) {
      dv = Matrix(self.adapter.constraintvalue())
      if (dv.norm()<self.ctol) return 

      var cgrad = self.adapter.constraintgradient()
      var n = cgrad.count()

      var M = Matrix(n,n)
      for (i in 0...n) for (j in i...n) M[i,j]=cgrad[i].inner(cgrad[j])

      var scale=dv/M

      for (i in 0...n) x -= scale[i]*cgrad[i]
      
      self.adapter.set(x)
    }

    _MaxIterCons.warning("Maximum number of constraint steps exceeded without achieving the constraint tolerance of ${self.ctol} (residual is ${dv.norm()}). Try setting 'maxconstraintsteps' to more than ${self.maxconstraintsteps}, or increase constraint tolerance.")
  }

  hasconverged() {
    if (super.hasconverged()) return true 

    if (self._valuehistory.count()>1 &&
        abs(self._valuehistory[-2]-self._valuehistory[-1])<self.etol) return true 

    return false  
  }

}

var start = Matrix([1,0])

var adapt = FunctionAdapter(func, start=start, constraints = [g])

var control = ProjectedGradientDescentController(adapt)

control.optimize(100)

print "Final constraint norm: ${Matrix(adapt.constraintvalue()).norm()}"

print "Solution:"
print adapt.get()